<#
QuoteSync — Extract Types from src\App.tsx into src\models\types.ts
Date: 2026-02-20
Run from: PS C:\Github\QuoteSync\web\ps1_patches>

What it does:
- Creates backup: C:\Github\QuoteSync\web\_backups\<timestamp>\App.tsx
- Extracts the block between:
    /* =========================
       Types
    ========================= */
  and
    /* =========================
       Helpers
    ========================= */
- Writes it to: src\models\types.ts (as exported types)
- Replaces the original Types block in App.tsx with an import from "./models/types"
- Fails fast if markers are missing, duplicated, or extraction is empty.

Notes:
- No UI/layout changes.
- No behaviour changes.
#>

$ErrorActionPreference = "Stop"

function Ok($m){ Write-Host "OK: $m" -ForegroundColor Green }
function Warn($m){ Write-Host "WARN: $m" -ForegroundColor Yellow }
function Fail($m){ Write-Host "ERROR: $m" -ForegroundColor Red; throw $m }

Write-Host "Run directory (current): $((Get-Location).Path)"
Write-Host "Script root           : $PSScriptRoot"

# Resolve web root (script is in web\ps1_patches)
$PatchDir = Resolve-Path $PSScriptRoot | Select-Object -ExpandProperty Path
$WebRoot  = Resolve-Path (Join-Path $PatchDir "..") | Select-Object -ExpandProperty Path

if (-not (Test-Path (Join-Path $WebRoot "package.json"))) {
  Fail "Could not detect QuoteSync web root. Ensure you run from C:\Github\QuoteSync\web\ps1_patches"
}
Ok "Detected web root: $WebRoot"

$SrcDir = Join-Path $WebRoot "src"
$AppPath = Join-Path $SrcDir "App.tsx"
if (-not (Test-Path $AppPath)) { Fail "Missing: $AppPath" }

$ModelsDir = Join-Path $SrcDir "models"
$TypesPath = Join-Path $ModelsDir "types.ts"

# Backup
$stamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
$BackupDir = Join-Path (Join-Path $WebRoot "_backups") $stamp
New-Item -ItemType Directory -Force -Path $BackupDir | Out-Null
Copy-Item -Force $AppPath (Join-Path $BackupDir "App.tsx")
Ok "Backed up App.tsx -> $BackupDir\App.tsx"

$txt = Get-Content -LiteralPath $AppPath -Raw -Encoding UTF8

$startMarker = "/* =========================`r?`n   Types`r?`n========================= */"
$endMarker   = "/* =========================`r?`n   Helpers`r?`n========================= */"

# Find markers (regex, multiline)
$startRx = [regex]::new($startMarker, [System.Text.RegularExpressions.RegexOptions]::Multiline)
$endRx   = [regex]::new($endMarker,   [System.Text.RegularExpressions.RegexOptions]::Multiline)

$startMatches = $startRx.Matches($txt)
$endMatches   = $endRx.Matches($txt)

if ($startMatches.Count -ne 1) { Fail "Expected exactly 1 Types marker, found $($startMatches.Count)." }
if ($endMatches.Count   -ne 1) { Fail "Expected exactly 1 Helpers marker, found $($endMatches.Count)." }

$startIdx = $startMatches[0].Index + $startMatches[0].Length
$endIdx   = $endMatches[0].Index

if ($endIdx -le $startIdx) { Fail "Markers out of order (Helpers before Types end)." }

$typesBlock = $txt.Substring($startIdx, $endIdx - $startIdx).Trim()

if ([string]::IsNullOrWhiteSpace($typesBlock)) { Fail "Extracted types block is empty." }

# Ensure models dir
New-Item -ItemType Directory -Force -Path $ModelsDir | Out-Null

# Convert `type X =` to `export type X =`
# Also handle `type X =` preceded by whitespace.
$exported = $typesBlock -replace '(?m)^\s*type\s+([A-Za-z0-9_]+)\s*=', 'export type $1 ='

# Write types.ts (with a small header and keep the original comment markers for clarity)
$typesFile = @"
/**
 * QuoteSync — Centralised Types
 * Generated: $(Get-Date -Format "yyyy-MM-dd HH:mm:ssK")
 *
 * NOTE: This file is generated by a patch script.
 *       Do not edit marker structure lightly; it is used for safe future refactors.
 */

$exported
"@

Set-Content -LiteralPath $TypesPath -Value $typesFile -Encoding UTF8
Ok "Wrote: src\models\types.ts"

# Now replace the Types block in App.tsx with an import.
# We'll remove the original marker + extracted content, and insert an import block after existing imports.
# Strategy:
# - Remove from start marker up to just before helpers marker (keep helpers marker)
# - Insert an import line near the top after React import + GridEditor import block

# 1) Remove Types section (marker + body) but keep Helpers marker in place
$removeRx = [regex]::new("(?s)/\*\s*========================\s*`r?`n\s*Types\s*`r?`n\s*=========================\s*\*/\s*.*?(?=/\*\s*========================\s*`r?`n\s*Helpers\s*`r?`n\s*=========================\\s*\\*/)", [System.Text.RegularExpressions.RegexOptions]::Multiline)
$afterRemove = $removeRx.Replace($txt, "")

# 2) Insert import from ./models/types after the existing imports at top.
# We anchor on the existing GridEditor import line to avoid fragile patterns.
$anchor = 'import GridEditor from "./components/GridEditor";'
if ($afterRemove -notmatch [regex]::Escape($anchor)) { Fail "Anchor import not found: $anchor" }

$importLine = 'import type { MenuKey, ClientType, EstimateStatus, ProductType, View, Client, EstimateDefaults, Estimate, Position, EstimateOutcome, ClientNote, ClientFile, FollowUp } from "./models/types";'

# Avoid duplicate insertion
if ($afterRemove -match [regex]::Escape($importLine)) {
  Warn "Type import already present — skipping insert."
  $final = $afterRemove
} else {
  $final = $afterRemove -replace [regex]::Escape($anchor), ($anchor + "`r`n" + $importLine)
}

# Sanity check: App.tsx should no longer contain "Types" marker block
if ($final -match "(?m)^\s*/\*\s*========================\s*$" -and $final -match "(?m)^\s*Types\s*$") {
  Warn "Types marker still appears — please review, but continuing."
}

Set-Content -LiteralPath $AppPath -Value $final -Encoding UTF8
Ok "Updated: src\App.tsx"

Write-Host ""
Ok "Done. Next: run 'npm run dev' from C:\Github\QuoteSync\web to confirm build."
Write-Host ("Backup location: {0}" -f $BackupDir) -ForegroundColor Cyan
"