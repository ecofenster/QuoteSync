# =====================================================================
# QuoteSync â€” Phase 4: Supplier & Product Defaults (extract from App.tsx)
# Script: 20260220_15_phase4_extract_catalog_defaults_v2.ps1
# Run from: PS C:\Github\QuoteSync\web\ps1_patches>
#
# Based on CURRENT App.tsx structure (anchored extraction, no guessing).
# Moves ONLY this block (exactly once):
#   const PRODUCT_TYPES ... through end of const FINISHES_BY_TYPE = { ... };
#
# Creates:
#   src\features\catalog\defaultCatalog.ts
#
# Then App.tsx imports:
#   PRODUCT_TYPES, SUPPLIERS, WOOD_TYPES, FINISHES_BY_TYPE,
#   getSupplier, allProductsForSupplier, firstProductForSupplier, isTimberProductType
#
# Safety:
# - Auto-backup all touched files to _backups\<timestamp>\
# - Fail fast if anchors ambiguous or if target file already exists
# - No UI/layout/logic changes (data stays identical; only moved)
# =====================================================================

$ErrorActionPreference = "Stop"

function Ok($m){ Write-Host "OK: $m" -ForegroundColor Green }
function Info($m){ Write-Host "INFO: $m" -ForegroundColor Cyan }
function Fail($m){ Write-Host "ERROR: $m" -ForegroundColor Red; throw $m }

function Get-Text([string]$path){
  if (!(Test-Path $path)) { Fail "Missing file: $path" }
  return [System.IO.File]::ReadAllText($path, [System.Text.Encoding]::UTF8)
}
function Set-Text([string]$path, [string]$text){
  $dir = Split-Path -Parent $path
  if (!(Test-Path $dir)) { New-Item -ItemType Directory -Force -Path $dir | Out-Null }
  [System.IO.File]::WriteAllText($path, $text, [System.Text.Encoding]::UTF8)
}
function Ensure-Once([string]$name, [string]$text, [string]$pattern){
  $rx = [regex]::new($pattern, [System.Text.RegularExpressions.RegexOptions]::Multiline)
  $m = $rx.Matches($text)
  if ($m.Count -ne 1) { Fail "Ambiguous (expected 1 match, got $($m.Count)): $name" }
}
function Replace-Once([string]$name, [ref]$textRef, [string]$pattern, [string]$replacement){
  $rx = [regex]::new($pattern, [System.Text.RegularExpressions.RegexOptions]::Multiline)
  $m = $rx.Matches($textRef.Value)
  if ($m.Count -ne 1) { Fail "Ambiguous (expected 1 match, got $($m.Count)): $name" }
  $textRef.Value = $rx.Replace($textRef.Value, $replacement, 1)
}
function Ensure-NotPresent([string]$name, [string]$text, [string]$needle){
  if ($text -match [regex]::Escape($needle)) { Fail "Refusing to re-apply (already present): $name contains '$needle'" }
}
function Backup-File([string]$root, [string]$absPath, [string]$backupRoot){
  if (!(Test-Path $absPath)) { Fail "Cannot backup missing file: $absPath" }
  $rel = (Resolve-Path $absPath).Path.Substring((Resolve-Path $root).Path.Length).TrimStart('\')
  $dest = Join-Path $backupRoot $rel
  $destDir = Split-Path -Parent $dest
  if (!(Test-Path $destDir)) { New-Item -ItemType Directory -Force -Path $destDir | Out-Null }
  Copy-Item -Force $absPath $dest
  Ok "Backed up $rel -> $dest"
}

# --- Resolve project root (web) from ps1_patches ---
$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$root = Resolve-Path (Join-Path $scriptDir "..")  # ...\web
Set-Location $root
Info "Run directory: $root"

$timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
$backupRoot = Join-Path $root "_backups\$timestamp"
New-Item -ItemType Directory -Force -Path $backupRoot | Out-Null
Ok "Backup folder: $backupRoot"

$appPath = Join-Path $root "src\App.tsx"
$catalogPath = Join-Path $root "src\features\catalog\defaultCatalog.ts"

# Backup first
Backup-File $root $appPath $backupRoot
if (Test-Path $catalogPath) { Backup-File $root $catalogPath $backupRoot }

$appTxt = Get-Text $appPath

# Guards
Ensure-NotPresent "App.tsx already imports defaultCatalog" $appTxt './features/catalog/defaultCatalog'
if (Test-Path $catalogPath) { Fail "Refusing to overwrite existing file: src\features\catalog\defaultCatalog.ts" }

# Critical anchor: Models import must exist once (runtime)
Ensure-Once "App.tsx Models import anchor" $appTxt '^import \* as Models from "\./models/types";\s*$'

# EXACT block extraction (as observed in current App.tsx)
$blockPattern = '(?s)const PRODUCT_TYPES:[\s\S]*?const FINISHES_BY_TYPE:[\s\S]*?\r?\n\};\r?\n'
Ensure-Once "App.tsx defaults block (PRODUCT_TYPES..FINISHES_BY_TYPE)" $appTxt $blockPattern

$rx = [regex]::new($blockPattern, [System.Text.RegularExpressions.RegexOptions]::Multiline)
$block = $rx.Match($appTxt).Value

# Build new file content: add Models import + export the definitions
$catalogHeader = @"
// Auto-generated by Phase 4 extraction patch.
// Source of truth for Supplier/Product defaults (moved out of App.tsx).
import * as Models from "../../models/types";

"@

$catalog = $block

# Export type/const/functions that App.tsx uses
$catalog = $catalog -replace '(\r?\n)type SupplierCatalog =', '$1export type SupplierCatalog ='
$catalog = $catalog -replace '(^|\r?\n)const PRODUCT_TYPES:', '$1export const PRODUCT_TYPES:'
$catalog = $catalog -replace '(^|\r?\n)const SUPPLIERS:', '$1export const SUPPLIERS:'
$catalog = $catalog -replace '(^|\r?\n)const WOOD_TYPES =', '$1export const WOOD_TYPES ='
$catalog = $catalog -replace '(^|\r?\n)const FINISHES_BY_TYPE:', '$1export const FINISHES_BY_TYPE:'
$catalog = $catalog -replace '(^|\r?\n)function getSupplier\(', '$1export function getSupplier('
$catalog = $catalog -replace '(^|\r?\n)function allProductsForSupplier\(', '$1export function allProductsForSupplier('
$catalog = $catalog -replace '(^|\r?\n)function firstProductForSupplier\(', '$1export function firstProductForSupplier('
$catalog = $catalog -replace '(^|\r?\n)function isTimberProductType\(', '$1export function isTimberProductType('

# Ensure the catalog file doesn't accidentally still declare its own Models import (shouldn't)
Ensure-NotPresent "defaultCatalog.ts content" ($catalogHeader + $catalog) 'from "\./models/types"'

Set-Text $catalogPath ($catalogHeader + $catalog.TrimStart("`r","`n") + "`r`n")
Ok "Created: src\features\catalog\defaultCatalog.ts"

# Remove the block from App.tsx
Replace-Once "App.tsx remove inlined defaults block" ([ref]$appTxt) $blockPattern "`r`n"

# Insert import into App.tsx immediately after Models import
$importInsert = @'
import {
  PRODUCT_TYPES,
  SUPPLIERS,
  WOOD_TYPES,
  FINISHES_BY_TYPE,
  getSupplier,
  allProductsForSupplier,
  firstProductForSupplier,
  isTimberProductType,
} from "./features/catalog/defaultCatalog";

'@

Replace-Once "App.tsx insert defaultCatalog import" ([ref]$appTxt) '(?m)^(import \* as Models from "\./models/types";\r?\n)' "`$1$importInsert"

Set-Text $appPath $appTxt
Ok "Patched: src\App.tsx"

Ok "Phase 4 extraction complete (Supplier & Product Defaults moved out of App.tsx)."
Info "Next: npm run dev"
